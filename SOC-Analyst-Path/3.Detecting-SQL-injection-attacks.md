# What is SQL Injection (SQLi)?
These type of attacks are critical due to the type of information that can be leaked. These attacks occur in web applications that include unsanitized access to the data using SQL queries. Nowadays, frameworks used to develop web apps have preventive mechanisms to avoid the leakage of data through SQL injections. Nonetheless, some updates can lead to a possible SQL Injection, and more often than not, the user might not be using the framework properly, thus backing up the fact of the user being the weakest link in the chain.

## Types of SQL injections
- **In-band SQLi (Classic SQLi)**: The process of injection and the retrival of results occurs on the same channel of communication.
- **Inferential SQLi (Blind SQLi)**: Queries that receive a response but cannot be seen are called this way. 
- **Out-of-band SQLi**: The response to a SQL query is communicated through another channel. For example, if an attacker receives replies to a SQL query via DNS.

# How does SQL Injection work?
Web applications are built so there can be some type of communication between the user and a web server. This interchange of information is made through user input, allowing them to retrieve data and displaying specific content. This communication process is the cornerstone of these types of attacks, exploting improper input validation and insecure query construction.

A user is expected to enter their credential data on the login page. This is translated into SQL query to retrieve data from the DB like the one below:

`SELECT * FROM users WHERE username='USERNAME' AND password='USER_PASSWORD'`
>This query basically means "Bring the information of certain username from the users table with the USERNAME and USER_PASSWORD". If the credentials create a match, then the user will be authenticated, otherwise, if there's no user with those credentials in the DB, the login will fail.

Now, lets assume that these inputs don't have any validation, of course if we type the correct format the system will continue to run without errors (authenticating users or failing to log in). But, what if we change the format of one of the inputs to create a `SQL Syntax Error`.

Lets assume our username is "einar" and the password is "bjorn". The same query than before will work:

`SELECT * FROM users WHERE username='einar' AND password='bjorn'`

This time we will put an ' before the name, breaking the SQL Syntax and escaping the Name parameter:

`SELECT * FROM users WHERE username='einar'' AND password='bjorn'`
> SELECT * FROM users WHERE login= "'Error: you have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near"'" at line 1

If an error occurs at this stage it means the attackers are on the right track, allowing them to manipulate the information in the error message to their advantage.

Another example is when the attacker use a payload to access to data in the DB. For this, the attacker can use the next query:

`SELECT * FROM users WHERE username=' ' OR 1=1 -- -' AND password='bjorn';` 
> The -- - is the syntax for comments, therefore everything after that is ignored
`SELECT * FROM users WHERE username=' ' OR 1=1 '`
> This syntax means "if the username is empty or 1=1", as 1 will always be equal to 1 the query will always be true and will return the first value of the table. Other parameter can be attached so the number of rows can be returned.

This example are typical cases of an *in-band SQL injection*, and to be more specific is one of two subtypes called `error-based SQL injection`. The other subtype is the `union-based SQL injection`.

The `union-based SQL injections` occur when the attacker extracts data by appending additional queries using the `UNION` operator:

`SELECT id, username, email FROM users WHERE id= '" + user_input"';`

The attack input will be: `' UNION SELECT null, version(), null --`, resulting in:

`SELECT id, username, email FROM users WHERE id=' ' UNION SELECT null, vers:`
>The DB responds with the version number, confirming the vulnerability

## Risks of SQL Injection
- *Data Exfiltration*: Attackers can retrieve sensitive information, such usernames, passwords, and finantial records.
- *Authentication Bypass*: Exploiting authentication mechanisms to gain unauthorized access.
- *Data Manipulation*: Attackers may modify or delete critical records.
- *System Compromise*: Exploiting SQL injection in conjunction with other vulnerabilities may lead to full system control.
- *Regulatory Non-Compliance*: Breaches resulting from SQLi can violate GDPR, PCI, DSS, and other compliance standards.

## How to prevent SQLi
- *Use a Framework*: Frameworks usually come with input validation. It's important to use the framework according to the documentation to avoid possible breaches in security.
- *Framework Up to date*: Keep security updates
- *Sanitize data received from a user*: Never trust data received from a user. Always sanitize all data (Headers, URL params, etc.)
- *Avoid Raw SQL queries*: Instead of writting raw SQL queries to access the DB, use the specific form of retrieving data provided by the framework.

## Detectiong SQLi Attacks
- When examining a web request, check all areas that come from the user: SQLi attacks don't always relay on **forms**, check **HTTP Requests headers** such as the *"User-Agent"*.
- Look for SQL keywords: If you find keywords like **INSERT, SELECT,** and **WHERE** in the data received from users, then an SQLi Attack might be taking place
- Check for any special characters: As we saw in the SQL snippets, the idea is to close SQL clause, and inject a malicious sentence to gain information. Characters like **(')**,**(-)**, or **parenthesis** are a clue to these type of attacks.
- Familiarise yourself with commonly used SQLi payloads: Most of the times SQL **payloads** change depending on the web application. But, sometimes attackers will relay on using common payloads to test for SQLi vulnerabilities. [More info about payloads](https://github.com/payloadbox/sql-injection-payload-list).

## Detecting Automated SQLi Tools
These tools are made to automate the attack, exploiting the possible SQL vulnerabilities a system may present. The following methods are created to identify these tools:
- Look at the User-Agent: Automated Tools usually have their names and versions recorded.
- Check the frequency of requests: Typically, a normal user might send 1 request per second. With automated tools this changes to a estimated number of requests per second to test payloads as quickly as possible.
- Look at the content of the payload: These tools usually leave their names into the payloads sent. For example, the tool **Sqlmap** will leave a trace like `sqlmap ' OR 1=1`.
- Complicated payload: As these tools are programmed beforehand, allows the attacker to create more complex queries to achieve its goal. Although, this method does not correlate all the time. Complex queries doesn't neccesarily point to an automated SQli.

#### Access Log: Logs of a web server that contain IP address, date, requested URL, HTTP method, user agent, and HTTP response code.
``` 
E.x:

192.168.31.174 - - [19/Feb/2022 11:09:23] "GET" /?id=1 HTTP/1.1" 200 -
192.168.31.174 - - [19/Feb/2022 11:09:23] "GET" /?id=1 HTTP/1.1" 200 -
192.168.31.174 - - [19/Feb/2022 11:09:23] "GET" /?id=9167 HTTP/1.1" 200 -
192.168.31.174 - - [19/Feb/2022 11:09:23] "GET" /?id=1%22%28%28%2C .. %27%28%29%28 HTTP/1.1" 200 -

```
Once we have access to these logs, we can see what resources have been requested. Pages like "info.php" are quite readable, but most of the cases the request is more complex and utilizes a **Percentage Encoding**. This encoding takes place before the request is sent to the web server, and it's done by the web browser, replacing the special character with a starting **%** and 2 hexadecimal characters. Pages with these special characters does not always tells us that a malicious attack is going on, but if they are repeated many times it may suggest some suspicious activity.

|Chracter|UTF-8|
|---|---|
|space|%20|
|!|%21|
|"|%22|
|#|%23|
|$|%24|
|%|%25|
|&|%26|
|'|%27|
|(|%28|
|)|%29|

Continuing with the detection, we can clearly see some SQL keywords being used (UNION, SELECT, AND, CHR) next to the %. This suggest that we are facing an SQLi Attack. There are some tools that can help **decode** the Percentage Encoding, but bare in mind that most of the access logs contain critical business information and is not recommendable to upload such resources to a 3rd party web app.

After looking for the resources requested in the query, we can also look to the **Date** section. In the case at hand, we can see that 40+ requests have been made in less than 2 seconds, and as we establish before, normal request are made in the span of 1 second each. Having so many request made under 1 second suggest this was made through an automated SQLi Tool.


